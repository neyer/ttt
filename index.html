<html>
<head>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r68/three.min.js"></script>
<script src="http://threejs.org/examples/js/controls/FlyControls.js"></script>
<script src="http://threejs.org/examples/js/ParametricGeometries.js"></script>
<style>canvas { width: 100%; height: 100% }</style>
<script>
var ttt = {
  ScreenWidth : 1280,
  ScreenHeight : 1024,
  ViewAngle : 45,
  NearPlane : 0.1,
  FarPlane : 100000,
  NumTurns : 2,
};
(window.onpopstate = function () {
    var match,
        pl     = /\+/g,  // Regex for replacing addition symbol with a space
        search = /([^&=]+)=?([^&]*)/g,
        decode = function (s) { return decodeURIComponent(s.replace(pl, " ")); },
        query  = window.location.search.substring(1);

    while (match = search.exec(query)){
       ttt[decode(match[1])] = decode(match[2]);
      console.log('adding param '+match[1]+'='+match[2]);
    }
})();
$(document).ready(function(){
// set the scene size
var aspectRatio =  ttt.ScreenWidth / ttt.ScreenHeight;
var $container = $('#container');
var renderer = new THREE.WebGLRenderer();
var camera = new THREE.PerspectiveCamera(ttt.ViewAngle, aspectRatio, ttt.NearPlane, ttt.FarPlane);

//create a scene and controls
var scene = new THREE.Scene();
scene.add(camera);
var controls = new THREE.FlyControls(camera);
controls.movementSpeed = 1000;
controls.domElement = $container[0];
controls.rollSpeed = Math.PI/16;
controls.autoForward = false;
controls.dragToLook = true;
// the camera starts at 0,0,0
// so pull it back
camera.position.z = 300;
var clock = new THREE.Clock();

// start the renderer
renderer.setSize(ttt.ScreenWidth, ttt.ScreenHeight);
$container.append(renderer.domElement);


// configuration stuff for board objects
var height = 100;
var width = 2;
var spacePerTurn = height*1.2; 
  
var barGeom = new THREE.CylinderGeometry( width, width, height, 40, 5 );
var xBarGeom = new THREE.CylinderGeometry( width, width, height*0.3, 40, 5 );
var oGeom = new THREE.TorusGeometry(height*0.1, width, 8, 10);
// prepare some materials for rendering
var whiteMaterial = new THREE.MeshLambertMaterial({color:0xffffff});
var redMaterial = new THREE.MeshLambertMaterial({color:0xcc0000});
var greenMaterial = new THREE.MeshLambertMaterial({color:0x00cc00});


// how many configurations can be reached each turn? comes from some math
var configsPerTurn = [1, 9, 72, 252, 756, 1260, 1680, 1260, 630, 630 ];

var layersMap = {};
var Configuration = function (board) {
 var c =  {
 board : board,
 turnNumber : 0,
 computeOffset: function() {
  var config = board;
  var numPieces  = 0;
  for (var iy = 0; iy < 3; ++ iy) {
    for (var ix = 0; ix < 3; ++ ix) {
        var piece = config[iy][ix];
        if (piece != 0) {
            ++ numPieces;
        }
    }
  }
  this.turnNumber = numPieces;
  this.isXTurn = numPieces %  2 == 0;
  var squareSize = Math.sqrt(configsPerTurn[numPieces]);
  var dz  = -spacePerTurn*squareSize;
  var dx = 0, dy = 0;
  squareSize = Math.floor(squareSize);
  // first, get the rows map for this z axis
  var thisLayer = layersMap[numPieces];
  if (typeof thisLayer === 'undefined') {
    thisLayer = { configs: {}, row: 0, column : 0};
    layersMap[numPieces] = thisLayer;
  }
  // see if there's already a position for this config
  var thisConfigPos = thisLayer.configs[this.signature];
  if (typeof thisConfigPos === 'undefined') {

   var layerSizeOffset = squareSize*spacePerTurn*0.5;
   dy = thisLayer.row*spacePerTurn - layerSizeOffset;
   dx = thisLayer.column*spacePerTurn - layerSizeOffset;

    thisConfigPos = { x : dx, y : dy };
    thisLayer.configs[this.signature] = thisConfigPos;

   //now advance where the next config in this row should go
   if(++thisLayer.column >= squareSize) {
      ++thisLayer.row;
       thisLayer.column = 0;
   }
  } else {
    dx = thisConfigPos.x;
    dy = thisConfigPos.y;
 } 

     return [ dx, dy, dz];
 },

 makeGeometry : function (){
  var offset = height/6; // two offset should be one third of the space here
  var rootObj = new THREE.Object3D();
  rootObj.position.copy(this.offsetVec);
  var imageFile = 'images/'+this.signature+'.png';
  var textureMap = THREE.ImageUtils.loadTexture(imageFile);
  var material =  new THREE.MeshBasicMaterial({
   color:0xffffff,
   overdraw: true,
   transparent : true,
   map:textureMap});

  var plane = new THREE.Mesh(new THREE.PlaneGeometry(100,100,1,1), material)
  rootObj.add(plane);
  scene.add(rootObj);
  return;


  // put the bars in here
  var leftBar = new THREE.Mesh(barGeom, whiteMaterial);
      leftBar.position.set(- offset, 0, 0);
  rootObj.add( leftBar);

  var rightBar = new THREE.Mesh(barGeom, whiteMaterial);
  rightBar.position.set(offset, 0, 0);
  rootObj.add(rightBar)

   var topBar = new THREE.Mesh(barGeom, whiteMaterial);
   topBar.rotation.set(0,0,Math.PI/2);
   topBar.position.set(0,offset,0);
   rootObj.add(topBar);

  var bottomBar = new THREE.Mesh(barGeom, whiteMaterial);
  bottomBar.rotation.set(0,0,Math.PI/2);
  bottomBar.position.set(0,-offset,0);
  rootObj.add(bottomBar);
  // now add the elements
  for (var iy = 0; iy < 3; ++ iy) {
    for (var ix = 0; ix < 3; ++ ix){
      var val = this.board[iy][ix];

      var offsetX = (ix - 1)*height*0.333;
      var offsetY = (iy - 1)*height*0.333;
      if (val == 1) {
        // make an x here
        var xCrossLeft = new THREE.Mesh(xBarGeom, redMaterial);
        xCrossLeft.rotation.set(0,0,Math.PI/4)
        var xCrossRight = new THREE.Mesh(xBarGeom, redMaterial);
        xCrossRight.rotation.set(0,0,-Math.PI/4);
        xCrossLeft.position.set(offsetX, offsetY, 0);
        xCrossRight.position.set(offsetX, offsetY, 0);
        rootObj.add(xCrossLeft);
        rootObj.add(xCrossRight);
      } else if (val == -1) {
        // make an o here
        var circle = new THREE.Mesh(oGeom, greenMaterial);
        circle.position.set(offsetX,offsetY, 0);
        rootObj.add(circle); 
      }
    }
  }
  scene.add(rootObj);
 },
 makeSubturns : function (){
  // now add the subturns
  if (this.turnNumber < ttt.NumTurns){
  var nextTurn = makeNextTurn(configuration);
  var i = 0;
   for (i = 0; i <  nextTurn.configs.length; ++ i) {
       Configuration(nextTurn[i]);
     } 
   }
  },
 copyBoard: function(){
    var result = [
      [0,0,0,],
      [0,0,0,],
      [0,0,0,],
    ]; for (var iy = 0; iy < 3; ++ iy){
      for (var ix = 0; ix < 3; ++ ix){
            result[iy][ix] = this.board[iy][ix];
      }
    }
    return result;
  },

  makeString: function(){
    return [c.board[0].join(),c.board[1].join(),c.board[2].join()].join();
  }
 };

 c.signature = c.makeString();
 c.offset = c.computeOffset();
 c.offsetVec = new THREE.Vector3(c.offset[0], c.offset[1], c.offset[2]);
 return c;
} // end Configuration function 

function Move(oldConfig, newConfig) {
  return {
    old : oldConfig,
    new : newConfig,
    makeGeometry : function (){
      
      var pathInterpolate = function (percent) {
        var direction = new THREE.Vector3();
        direction.subVectors(newConfig.offsetVec, oldConfig.offsetVec);
        direction.multiplyScalar(percent);
        var result = new THREE.Vector3();
        return result.addVectors(oldConfig.offsetVec, direction);
        
      }
      var object = new THREE.Object3D();
      var points = [ oldConfig.offsetVec,
                     pathInterpolate(1.2)];  
      var arrow = new THREE.TubeGeometry(new THREE.SplineCurve3(points), 4, width, 8, true);
      var mesh = new THREE.Mesh(arrow, oldConfig.isXTurn ? redMaterial : greenMaterial);
      scene.add(mesh);
    },
  };
}

var configurationCache = {};
var moveCache = {};
function isNewConfiguration(c){
  if (typeof configurationCache[c.signature] === 'undefined'){
    configurationCache[c.signature] = true;
    return true;
  }
  return false;
}

function isNewMove(configA, configB){
  var s1 = configA.signature,
      s2 = configB.signature;
  var s= s1+";"+s2;
  if (typeof moveCache[s] === 'undefined') {
    moveCache[s] = true;
    return true;
  }
  return false;
}

function makeNextTurn(configuration){
  var nextTurn = { 'configs' : [], 'moves' : [], 'turnCount' : configuration.turnNumber + 1 };
  var ix, iy;
  for (iy = 0; iy < 3; ++iy) {
    for (ix = 0; ix < 3; ++ ix) {
      var here = configuration.board[iy][ix];
      if (here == 0){
        var newBoard = configuration.copyBoard();
        newBoard[iy][ix] = configuration.isXTurn ? 1 : -1;
        var newConfig = Configuration(newBoard);
        if (isNewConfiguration(newConfig)){
          nextTurn.configs.push(newConfig);
        }
        if (isNewMove(configuration, newConfig))
          nextTurn.moves.push(Move(configuration, newConfig));
      }
    }
  }
  return nextTurn;  
}

function processTurn(newTurn){
  var i = 0;
  for (i = 0; i < newTurn.configs.length; ++i){
    newTurn.configs[i].makeGeometry();
    if (newTurn.turnCount < ttt.NumTurns) {
        var next = makeNextTurn(newTurn.configs[i]);
        processTurn(next);
    }
  } 

  for (i = 0; i < newTurn.moves.length; ++i) {
      newTurn.moves[i].makeGeometry();
  }

   
}

//make actual scene
var endConfiguration= [
     [-1,1,-1],
     [1,-1,1],
     [-1,-1,0],
 ];

var baseConfiguration = [
  [ 0,0,0],
  [ 0,0,0],
  [ 0,0,0],
];

ttt.baseConfig  = Configuration(baseConfiguration);
ttt.baseConfig.makeGeometry();
ttt.turn = makeNextTurn(ttt.baseConfig, true);
processTurn(ttt.turn);

// create a lighting

var pointLight =
  new THREE.PointLight(0xFFFFFF);

pointLight.position.x = 10;
pointLight.position.y = 50;
pointLight.position.z = 130;
scene.add(pointLight);
scene.add(new THREE.AmbientLight(0x8a8b8c));

function render() {
  renderer.render(scene, camera)
  controls.update(clock.getDelta());
  requestAnimationFrame(render);
}

render();


});

</script>
</head>
<body>
<div id="container"/>
</body>
</html>
