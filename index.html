<html>
<head>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r68/three.min.js"></script>
<script src="http://threejs.org/examples/js/controls/FlyControls.js"></script>
<script src="http://threejs.org/examples/js/ParametricGeometries.js"></script>
<style>canvas { width: 100%; height: 100% }</style>
<script>
$(document).ready(function(){
// set the scene size
var WIDTH = 1280,
    HEIGHT = 1024,
  VIEW_ANGLE = 45,
  ASPECT = WIDTH / HEIGHT,
  NEAR = 0.1,
  FAR = 100000,
  numTurns = 2;

// get the DOM element to attach to
// - assume we've got jQuery to hand
var $container = $('#container');

// create a WebGL renderer, camera
// and a scene
var renderer = new THREE.WebGLRenderer();
var camera =
  new THREE.PerspectiveCamera(
    VIEW_ANGLE,
    ASPECT,
    NEAR,
    FAR);

//create a scene and controls
var scene = new THREE.Scene();
scene.add(camera);
var controls = new THREE.FlyControls(camera);
controls.movementSpeed = 1000;
controls.domElement = $container[0];
controls.rollSpeed = Math.PI/16;
controls.autoForward = false;
controls.dragToLook = true;
// the camera starts at 0,0,0
// so pull it back
camera.position.z = 300;
var clock = new THREE.Clock();

// start the renderer
renderer.setSize(WIDTH, HEIGHT);
$container.append(renderer.domElement);


// configuration stuff for board objects
var height = 100;
var width = 2;
var spacePerTurn = height*1.2; 
  
var barGeom = new THREE.CylinderGeometry( width, width, height, 40, 5 );
var xBarGeom = new THREE.CylinderGeometry( width, width, height*0.3, 40, 5 );
var oGeom = new THREE.TorusGeometry(height*0.1, width, 8, 10);
// prepare some materials for rendering
var whiteMaterial = new THREE.MeshLambertMaterial({color:0xffffff});
var redMaterial = new THREE.MeshLambertMaterial({color:0xcc0000});
var greenMaterial = new THREE.MeshLambertMaterial({color:0x00cc00});


// how many configurations can be reached each turn? comes from some math
var configsPerTurn = [1, 9, 72, 252, 1260, 1680, 1260, 630, 630 ];
var layersMap = {};

var Configuration = function (board) {
 var c =  {
 board : board,
 turnNumber : 0,
 computeOffset: function() {
  var config = board;
  var numPieces  = 0;
  var dy = 0;
  for (var iy = 0; iy < 3; ++ iy) {
    for (var ix = 0; ix < 3; ++ ix) {
        var piece = config[iy][ix];
        if (piece != 0) {
            ++ numPieces;
        }
    }
  }
  this.turnNumber = numPieces;
  var squareSize = Math.sqrt(configsPerTurn[numPieces]);
  var dz  = -spacePerTurn*squareSize;
  squareSize = Math.floor(squareSize);
  // first, get the rows map for this z axis
  var thisLayer = layersMap[numPieces];
  if (typeof thisLayer === 'undefined') {
    thisLayer = { row : 0, column : 0};
    layersMap[numPieces] = thisLayer;
  }
   dy = thisLayer.row*spacePerTurn;
   var dx = thisLayer.column*spacePerTurn;

   if(++thisLayer.column >= squareSize) {
      ++thisLayer.row;
       thisLayer.column = 0;
   }
  return [ dx, dy, dz];
 },

 makeGeometry : function (){
  var offset = height/6; // two offset should be one third of the space here
  var isXTurn = this.turnNumber % 2 == 0;
  var gridOffset = this.computeOffset();
  var x = gridOffset[0]; 
  var y = gridOffset[1];
  var z = gridOffset[2];

  // put the bars in here
  var leftBar = new THREE.Mesh(barGeom, whiteMaterial);
      leftBar.position.set( x - offset, y, z );
  scene.add( leftBar);

  var rightBar = new THREE.Mesh(barGeom, whiteMaterial);
  rightBar.position.set(x + offset, y, z);

  scene.add(rightBar)

   var topBar = new THREE.Mesh(barGeom, whiteMaterial);
   topBar.rotation.set(0,0,Math.PI/2);
   topBar.position.set(x,y+offset,z);
   scene.add(topBar);

  var bottomBar = new THREE.Mesh(barGeom, whiteMaterial);
  bottomBar.rotation.set(0,0,-Math.PI/2);
  bottomBar.position.set(x,y-offset,z);
  scene.add(bottomBar);
  // now add the elements
  for (var iy = 0; iy < 3; ++ iy) {
    for (var ix = 0; ix < 3; ++ ix){
      var val = this.board[iy][ix];

      var offsetX = (ix - 1)*height*0.333;
      var offsetY = (iy - 1)*height*0.333;
      if (val == 1) {
        // make an x here
        var xCrossLeft = new THREE.Mesh(xBarGeom, redMaterial);
        xCrossLeft.rotation.set(0,0,Math.PI/4)
        var xCrossRight = new THREE.Mesh(xBarGeom, redMaterial);
        xCrossRight.rotation.set(0,0,-Math.PI/4);
        xCrossLeft.position.set(x+offsetX, y+offsetY, z);
        xCrossRight.position.set(x+offsetX, y+offsetY, z);
        scene.add(xCrossLeft);
        scene.add(xCrossRight);
      } else if (val == -1) {
        // make an o here
        var circle = new THREE.Mesh(oGeom, greenMaterial);
        circle.position.set(x+offsetX, y+offsetY, z);
        scene.add(circle); 
      }
    }
  }
 },
 makeSubturns : function (){
  // now add the subturns
  if (this.turnNumber < numTurns){
  var nextTurn = makeNextTurn(configuration, isXTurn);
  var i = 0;
   for (i = 0; i <  nextTurn.configs.length; ++ i) {
       Configuration(nextTurn[i]);
     } 
   }
  },
 copyBoard: function(){
    var result = [
      [0,0,0,],
      [0,0,0,],
      [0,0,0,],
    ];
    for (var iy = 0; iy < 3; ++ iy){
      for (var ix = 0; ix < 3; ++ ix){
            result[iy][ix] = this.board[iy][ix];
      }
    }
    return result;
  },

  makeString: function(){
    return [c.board[0].join(),c.board[1].join(),c.board[2].join()].join();
  }
 };

 c.offset = c.computeOffset();
 c.signature = c.makeString();
 return c;
}

var configurationCache = {};
var moveCache = {};
function isNewConfiguration(c){
  if (typeof configurationCache[c.signature] === 'undefined'){
    configurationCache[c.signature] = true;
    return true;
  }
  return false;
}

function isNewMove(configA, configB){
  var s1 = configA.signature,
      s2 = configB.signature;
  var s= s1+";"+s2;
  if (typeof moveCache[s] === 'undefined') {
    moveCache[s] = true;
    return true;
  }
  return false;
}

function makeNextTurn(configuration, isXTurn){
  var nextTurn = { 'configs' : [], 'moves' : [] };
  var ix, iy;
  for (iy = 0; iy < 3; ++iy) {
    for (ix = 0; ix < 3; ++ ix) {
      var here = configuration.board[iy][ix];
      if (here == 0){
        var newBoard = configuration.copyBoard();
        newBoard[iy][ix] = isXTurn ? 1 : -1;
        var newConfig = Configuration(newBoard);
        if (isNewConfiguration(newConfig)){
          nextTurn.configs.push(newConfig);
        }
        if (isNewMove(configuration, newConfig))
          nextTurn.moves.push(configuration, newConfig);
      }
    }
  }
  return nextTurn;  
}

function processTurn(newTurn){
  var i = 0;
  for (i = 0; i < newTurn.configs.length; ++i){
    newTurn.configs[i].makeGeometry();
  }
}

//make actual scene
var endConfiguration= [
     [-1,1,-1],
     [1,-1,1],
     [-1,-1,0],
 ];

var baseConfiguration = [
  [ 0,0,0],
  [ 0,0,0],
  [ 0,0,0],
];

var c = Configuration(baseConfiguration);
c.makeGeometry();
var t = makeNextTurn(c, true);
processTurn(t);

// create a lighting

var pointLight =
  new THREE.PointLight(0xFFFFFF);

pointLight.position.x = 10;
pointLight.position.y = 50;
pointLight.position.z = 130;
scene.add(pointLight);
scene.add(new THREE.AmbientLight(0x8a8b8c));


function render() {
  renderer.render(scene, camera)
  controls.update(clock.getDelta());
  requestAnimationFrame(render);
}

render();


});

</script>
</head>
<body>
<div id="container"/>
</body>
</html>
